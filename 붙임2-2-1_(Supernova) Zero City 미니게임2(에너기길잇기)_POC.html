<!DOCTYPE html> 
<html lang="ko"> 
<head> 
    <meta charset="UTF-8"> 
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
    <title>Zero City: 에너지 길잇기 POC v2</title> 
    <script src="https://cdn.tailwindcss.com"></script> 
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"> 
    <style> 
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap'); 
        body { 
            font-family: 'Orbitron', sans-serif; 
            background-color: #0c1427; 
            color: #E0F2FE; 
            overflow: hidden; 
            touch-action: none; 
        } 
        #game-container { 
            position: relative; 
            width: 100%; 
            height: 100%; 
            background: radial-gradient(ellipse at bottom, #1b2735 0%, #090a0f 100%); 
            cursor: crosshair; 
        } 
        canvas { 
            position: absolute; 
            top: 0; left: 0; width: 100%; height: 100%; 
            pointer-events: none; 
        } 
        .game-object { 
            position: absolute; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            transition: all 0.3s ease; 
            user-select: none; 
        } 
        #smr-plant { 
            width: 120px; height: 120px; 
            background-color: rgba(14, 165, 233, 0.2); 
            border: 3px solid #0ea5e9; 
            border-radius: 50%; 
            box-shadow: 0 0 20px #0ea5e9, 0 0 40px #0ea5e9, inset 0 0 15px rgba(14, 165, 233, 0.5); 
            font-size: 14px; 
            color: white; 
            text-shadow: 0 0 5px black; 
            flex-direction: column; 
        } 
        #smr-plant i { font-size: 3rem; margin-bottom: 5px; } 
 
        .house { 
            width: 80px; height: 80px; 
            font-size: 3.5rem; 
            color: #6b7280; /* 어두운 효과 */ 
        } 
        .house.powered { 
            color: #facc15; /* 전력 공급 시 컬러로 */ 
            text-shadow: 0 0 15px #facc15, 0 0 30px #fde047; 
            transform: scale(1.1); 
        } 
        #path-runner { 
            width: 50px; height: 50px; 
            font-size: 2.5rem; 
            color: #fde047; 
            text-shadow: 0 0 15px #facc15; 
            pointer-events: none; 
            z-index: 10; 
            display: none; /* Initially hidden */ 
        } 
        .obstacle { 
            width: 60px; 
            height: 60px; 
            border-radius: 50%; 
            font-size: 2rem; 
        } 
        .obstacle.bolt { 
            background-color: #4b0082; 
            border: 2px solid #8a2be2; 
            color: #e0b0ff; 
            box-shadow: 0 0 15px #8a2be2; 
        } 
        .obstacle.rock { 
            background-color: #44403c; 
            border: 2px solid #78716c; 
            color: #a8a29e; 
            box-shadow: 0 0 15px #78716c; 
        } 
        .obstacle.puddle { 
             background-color: #1e40af; 
            border: 2px solid #3b82f6; 
            color: #93c5fd; 
            box-shadow: 0 0 15px #3b82f6; 
        } 
 
        .ui-panel { 
            position: absolute; 
            top: 20px; 
            left: 20px; 
            right: 20px; 
            display: flex; 
            justify-content: space-between; 
            align-items: flex-start; 
            pointer-events: none; 
        } 
        @keyframes red-flash { 
            0%, 100% { box-shadow: inset 0 0 0 0 rgba(239, 68, 68, 0); } 
            50% { box-shadow: inset 0 0 100vw 50vh rgba(239, 68, 68, 0.3); } 
        } 
        .time-warning { 
            animation: red-flash 1s infinite; 
        } 
        .holographic-text { text-shadow: 0 0 5px #38bdf8, 0 0 10px #38bdf8; } 
    </style> 
</head> 
<body class="w-screen h-screen"> 
 
    <div id="game-container"> 
        <canvas id="drawing-canvas"></canvas> 
        <div id="smr-plant" class="game-object"> 
            <i class="fas fa-atom"></i> 
            <span>SMR PLANT</span> 
        </div> 
        <div id="path-runner" class="game-object"> 
            <i class="fas fa-bolt"></i> 
        </div> 
        <!-- Houses and Obstacles will be generated by JS --> 
    </div> 
 
    <div class="ui-panel"> 
        <div class="text-left bg-black/50 p-3 rounded-lg"> 
            <p class="text-xl font-bold">LEVEL <span id="level-display">1</span></p> 
            <p id="objective-text" class="text-sm text-slate-300">Connect 3 houses!</p> 
        </div> 
        <div class="text-right bg-black/50 p-3 rounded-lg"> 
            <p class="text-xl font-bold">TIME</p> 
            <p id="timer" class="text-4xl font-bold">30</p> 
        </div> 
    </div> 
     
    <!-- Modals --> 
    <div id="modal-start" class="fixed inset-0 bg-black/80 flex items-center justify-center z-50"> 
        <div class="text-center p-8"> 
            <h2 class="text-4xl font-bold mb-2 holographic-text">LEVEL <span id="start-level">1</span></h2> 
            <p class="text-slate-300 mb-8 text-lg">Draw a single line to connect all houses without crossing the path!</p> 
            <button id="start-button" class="bg-sky-600 hover:bg-sky-500 text-white font-bold py-3 px-8 rounded-lg text-2xl transition-transform transform hover:scale-105 shadow-[0_0_15px_#0ea5e9]">START MISSION</button> 
        </div> 
    </div> 
     <div id="modal-end" class="fixed inset-0 bg-black/80 flex items-center justify-center z-50 hidden"> 
        <div class="text-center bg-slate-900/80 backdrop-blur-sm p-8 rounded-lg border border-sky-500/50"> 
            <h2 id="end-title" class="text-5xl font-black mb-6 holographic-text">LEVEL COMPLETED</h2> 
            <p id="end-message" class="text-lg mb-6"></p> 
            <div class="bg-black/30 p-4 rounded-lg mb-8"> 
                <p class="text-yellow-400 text-lg"><i class="fas fa-coins"></i> ACQUIRED NOVA</p> 
                <p id="end-nova" class="text-4xl font-bold">0</p> 
            </div> 
            <button id="next-level-button" class="bg-green-600 hover:bg-green-500 text-white font-bold py-3 px-8 rounded-lg text-2xl transition-transform transform hover:scale-105 shadow-[0_0_15px_#22c55e]">NEXT LEVEL</button> 
        </div> 
    </div> 
 
    <audio id="bgm" loop preload="auto" src="https://cdn.pixabay.com/download/audio/2022/08/04/audio_2bbe613601.mp3?filename=inspiring-cinematic-ambient-116199.mp3"></audio> 
 
<script> 
document.addEventListener('DOMContentLoaded', () => { 
    const elements = { 
        gameContainer: document.getElementById('game-container'), 
        canvas: document.getElementById('drawing-canvas'), 
        smrPlant: document.getElementById('smr-plant'), 
        pathRunner: document.getElementById('path-runner'), 
        timer: document.getElementById('timer'), 
        levelDisplay: document.getElementById('level-display'), 
        objectiveText: document.getElementById('objective-text'), 
        startLevel: document.getElementById('start-level'), 
        modalStart: document.getElementById('modal-start'), 
        modalEnd: document.getElementById('modal-end'), 
        startButton: document.getElementById('start-button'), 
        nextLevelButton: document.getElementById('next-level-button'), 
        endTitle: document.getElementById('end-title'), 
        endMessage: document.getElementById('end-message'), 
        endNova: document.getElementById('end-nova'), 
        bgm: document.getElementById('bgm'), 
    }; 
     
    const ctx = elements.canvas.getContext('2d'); 
    let isDrawing = false; 
    let path = []; 
    let houses = []; 
    let obstacles = []; 
    let visitedHouses = new Set(); 
    let timeLeft = 30; 
    let timerInterval = null; 
    let currentLevel = 1; 
    let totalEarnedNova = 0; 
 
    function loadGameData() { 
        currentLevel = parseInt(localStorage.getItem('zeroCityMiniGame1Level') || '1'); 
        totalEarnedNova = parseInt(localStorage.getItem('zeroCityMiniGame1TotalNova') || '0'); 
        elements.startLevel.textContent = currentLevel; 
        elements.levelDisplay.textContent = currentLevel; 
    } 
    function saveGameData() { 
        localStorage.setItem('zeroCityMiniGame1Level', currentLevel); 
        localStorage.setItem('zeroCityMiniGame1TotalNova', totalEarnedNova); 
    } 
 
    function getLevelConfig(level) { 
        const numHouses = Math.min(8, 2 + level); 
        let obstacleTypes = []; 
        if (level >= 3) obstacleTypes.push({type: 'bolt', count: Math.min(3, Math.floor((level - 2) / 2))}); 
        if (level >= 6) obstacleTypes.push({type: 'rock', count: Math.min(2, Math.floor((level - 5) / 2))}); 
        if (level >= 9) obstacleTypes.push({type: 'puddle', count: Math.min(2, Math.floor((level - 8) / 2))}); 
        return { numHouses, obstacles: obstacleTypes }; 
    } 
 
    function resizeCanvas() { 
        elements.canvas.width = elements.gameContainer.clientWidth; 
        elements.canvas.height = elements.gameContainer.clientHeight; 
    } 
     
    function setupLevel() { 
        document.querySelectorAll('.house, .obstacle').forEach(el => el.remove()); 
        houses = []; 
        obstacles = []; 
         
        const config = getLevelConfig(currentLevel); 
        const allObjectsPos = [getSMRPos()]; 
 
        for (let i = 0; i < config.numHouses; i++) { 
            const houseEl = document.createElement('div'); 
            houseEl.className = 'game-object house'; 
            houseEl.innerHTML = `<i class="fas fa-house-chimney-crack"></i>`; 
            const pos = getNewPosition(allObjectsPos); 
            houseEl.style.left = `${pos.left - 40}px`; 
            houseEl.style.top = `${pos.top - 40}px`; 
            elements.gameContainer.appendChild(houseEl); 
            const house = { el: houseEl, left: pos.left, top: pos.top }; 
            houses.push(house); 
            allObjectsPos.push({left: pos.left, top: pos.top}); 
        } 
 
        config.obstacles.forEach(obsConfig => { 
            for (let i = 0; i < obsConfig.count; i++) { 
                const obsEl = document.createElement('div'); 
                obsEl.className = `game-object obstacle ${obsConfig.type}`; 
                let iconClass = 'fas fa-bolt'; 
                if (obsConfig.type === 'rock') iconClass = 'fas fa-mound'; 
                if (obsConfig.type === 'puddle') iconClass = 'fas fa-water'; 
                obsEl.innerHTML = `<i class="${iconClass}"></i>`; 
                const pos = getNewPosition(allObjectsPos); 
                obsEl.style.left = `${pos.left - 30}px`; 
                obsEl.style.top = `${pos.top - 30}px`; 
                elements.gameContainer.appendChild(obsEl); 
                obstacles.push({ el: obsEl, left: pos.left, top: pos.top }); 
                allObjectsPos.push({left: pos.left, top: pos.top}); 
            } 
        }); 
 
        elements.objectiveText.textContent = `Connect ${config.numHouses} houses!`; 
    } 
 
    function getNewPosition(existingObjects) { 
        let pos, overlaps; 
        do { 
            overlaps = false; 
            pos = { 
                left: Math.random() * (elements.gameContainer.clientWidth - 100) + 50, 
                top: Math.random() * (elements.gameContainer.clientHeight - 200) + 50 
            }; 
            for (const existing of existingObjects) { 
                if (Math.hypot(pos.left - existing.left, pos.top - existing.top) < 120) { 
                    overlaps = true; 
                    break; 
                } 
            } 
        } while (overlaps); 
        return pos; 
    } 
 
 
    function getSMRPos() { 
        const rect = elements.smrPlant.getBoundingClientRect(); 
        const containerRect = elements.gameContainer.getBoundingClientRect(); 
        return { left: rect.left - containerRect.left + rect.width / 2, top: rect.top - containerRect.top + rect.height / 2 }; 
    } 
 
    function getEventCoords(event) { 
        const rect = elements.canvas.getBoundingClientRect(); 
        const touch = event.touches ? event.touches[0] : event; 
        return { x: touch.clientX - rect.left, y: touch.clientY - rect.top }; 
    } 
 
    function startDrawing(e) { 
        const coords = getEventCoords(e); 
        const smrPos = getSMRPos(); 
        if (Math.hypot(coords.x - smrPos.left, coords.y - smrPos.top) < 60) { 
            isDrawing = true; 
            path = [smrPos]; 
            visitedHouses.clear(); 
            houses.forEach(h => h.el.classList.remove('powered')); 
            elements.pathRunner.style.display = 'block'; 
            moveRunner(smrPos); 
        } 
    } 
 
    function draw(e) { 
        if (!isDrawing) return; 
        e.preventDefault(); 
        const coords = getEventCoords(e); 
        path.push(coords); 
        moveRunner(coords); 
        redrawPath(); 
        checkHouseCollision(coords); 
        if (checkSelfIntersection() || checkObstacleCollision()) { 
            failStroke(); 
        } 
    } 
     
    function moveRunner(pos) { 
        elements.pathRunner.style.left = `${pos.x - 25}px`; 
        elements.pathRunner.style.top = `${pos.y - 25}px`; 
    } 
 
    function checkHouseCollision(coords) { 
        for (const house of houses) { 
            if (!visitedHouses.has(house) && Math.hypot(coords.x - house.left, coords.y - house.top) < 40) { 
                visitedHouses.add(house); 
                house.el.classList.add('powered'); 
            } 
        } 
    } 
 
    function checkObstacleCollision() { 
        const lastPoint = path[path.length - 1]; 
        for (const obstacle of obstacles) { 
            if (Math.hypot(lastPoint.x - obstacle.left, lastPoint.y - obstacle.top) < 30) { 
                return true; 
            } 
        } 
        return false; 
    } 
     
    function checkSelfIntersection() { 
        if (path.length < 5) return false; 
        const lastSegment = { p1: path[path.length - 2], p2: path[path.length - 1] }; 
        for (let i = 0; i < path.length - 3; i++) { 
            const segment = { p1: path[i], p2: path[i + 1] }; 
            if (segmentsIntersect(lastSegment.p1, lastSegment.p2, segment.p1, segment.p2)) { 
                return true; 
            } 
        } 
        return false; 
    } 
     
    function failStroke() { 
        isDrawing = false; 
        redrawPath('#ef4444'); 
        setTimeout(() => { 
            resetPath(); 
        }, 500); 
    } 
     
    function redrawPath(style = 'rgba(255, 255, 255, 0.7)') { 
        ctx.clearRect(0, 0, elements.canvas.width, elements.canvas.height); 
        if (path.length < 2) return; 
        ctx.beginPath(); 
        ctx.moveTo(path[0].x, path[0].y); 
        for (let i = 1; i < path.length; i++) ctx.lineTo(path[i].x, path[i].y); 
        ctx.strokeStyle = style; 
        ctx.lineWidth = 10; 
        ctx.lineCap = 'round'; 
        ctx.lineJoin = 'round'; 
        ctx.shadowColor = style; 
        ctx.shadowBlur = 15; 
        ctx.stroke(); 
    } 
     
    function resetPath() { 
        ctx.clearRect(0, 0, elements.canvas.width, elements.canvas.height); 
        path = []; 
        visitedHouses.forEach(h => h.el.classList.remove('powered')); 
        visitedHouses.clear(); 
        elements.pathRunner.style.display = 'none'; 
    } 
 
    function stopDrawing() { 
        if (!isDrawing) return; 
        isDrawing = false; 
        if (visitedHouses.size === houses.length) { 
            endGame(true); 
        } else { 
            failStroke(); 
        } 
    } 
 
    function updateTimer() { 
        timeLeft--; 
        elements.timer.textContent = timeLeft; 
        if (timeLeft <= 5 && timeLeft > 0) { 
            elements.gameContainer.classList.add('time-warning'); 
        } 
        if (timeLeft <= 0) { 
            endGame(false); 
        } 
    } 
     
    function resetGame() { 
        loadGameData(); 
        resizeCanvas(); 
        setupSMRPlant(); 
        setupLevel(); 
        timeLeft = 30; 
        elements.timer.textContent = timeLeft; 
        elements.gameContainer.classList.remove('time-warning'); 
        resetPath(); 
    } 
     
    function startGame() { 
        elements.modalStart.classList.add('hidden'); 
        resetGame(); 
        timerInterval = setInterval(updateTimer, 1000); 
    } 
 
    function endGame(isWin) { 
        clearInterval(timerInterval); 
        isDrawing = false; 
         
        if (isWin) { 
            const earnedNova = 100 * currentLevel; 
            totalEarnedNova += earnedNova; 
            elements.endTitle.textContent = "LEVEL COMPLETED"; 
            elements.endMessage.textContent = `You restored power to the village!`; 
            elements.endNova.textContent = earnedNova; 
            elements.nextLevelButton.textContent = "NEXT LEVEL"; 
            currentLevel++; 
            saveGameData(); 
        } else { 
            elements.endTitle.textContent = "MISSION FAILED"; 
            elements.endMessage.textContent = `Total accumulated NOVA from completed levels.`; 
            elements.endNova.textContent = totalEarnedNova; 
            elements.nextLevelButton.textContent = "RETRY"; 
        } 
        elements.modalEnd.classList.remove('hidden'); 
        elements.bgm.pause(); 
    } 
     
    function setupSMRPlant() { 
        const rect = elements.gameContainer.getBoundingClientRect(); 
        elements.smrPlant.style.left = `${rect.width / 2 - 60}px`; 
        elements.smrPlant.style.top = `${rect.height - 140}px`; 
    } 
     
    elements.startButton.addEventListener('click', () => { 
        if (elements.bgm.paused) { 
            const playPromise = elements.bgm.play(); 
            if (playPromise !== undefined) { 
                playPromise.catch(error => { 
                    console.error("Audio play was prevented.", error); 
                }); 
            } 
        } 
        startGame(); 
    }); 
 
    elements.nextLevelButton.addEventListener('click', () => { 
        elements.modalEnd.classList.add('hidden'); 
        elements.startLevel.textContent = currentLevel; 
        elements.modalStart.classList.remove('hidden'); 
    }); 
 
    // Drawing Listeners 
    elements.gameContainer.addEventListener('mousedown', startDrawing); 
    elements.gameContainer.addEventListener('mousemove', draw); 
    window.addEventListener('mouseup', stopDrawing); 
    elements.gameContainer.addEventListener('touchstart', startDrawing, { passive: false }); 
    elements.gameContainer.addEventListener('touchmove', draw, { passive: false }); 
    window.addEventListener('touchend', stopDrawing); 
     
    function segmentsIntersect(p1, p2, p3, p4) { 
        let det, gamma, lambda; 
        det = (p2.x - p1.x) * (p4.y - p3.y) - (p4.x - p3.x) * (p2.y - p1.y); 
        if (det === 0) { 
            return false; 
        } else { 
            lambda = ((p4.y - p3.y) * (p4.x - p1.x) + (p3.x - p4.x) * (p4.y - p1.y)) / det; 
            gamma = ((p1.y - p2.y) * (p4.x - p1.x) + (p2.x - p1.x) * (p4.y - p1.y)) / det; 
            return (0 < lambda && lambda < 1) && (0 < gamma && gamma < 1); 
        } 
    } 
 
    loadGameData(); 
}); 
</script> 
</body> 
</html> 
 
 
